---- DEBUG: DUMPING PARSE TREE ----
File with the following decls: 
  File_decl with these decls: 
    Part_decl: named 'Adder4_CLA', with stmts: 
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: a
        name: b
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: carryIn
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: out
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: carryOut
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=n/a
        isMemory=0
        name: g
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=n/a
        isMemory=0
        name: p
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=n/a
        isMemory=0
        name: car0
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car0
         accessing field 'g'
        Expr: IDENT, name = g
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car0
         accessing field 'p'
        Expr: IDENT, name = p
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car0
         accessing field 'carryIn'
        Expr: IDENT, name = carryIn
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=n/a
        isMemory=0
        name: c
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = out
        Expr: TWOOP of mode XOR with exprs
          LHand:
            Expr: TWOOP of mode XOR with exprs
              LHand:
                Expr: IDENT, name = a
              RHand:
                Expr: IDENT, name = b
          RHand:
            Expr: IDENT, name = c
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = carryOut
        Expr: TWOOP of mode BITWISE OR with exprs
          LHand:
            Expr: TWOOP of mode BITWISE OR with exprs
              LHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = a
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = b
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
              RHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = a
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = c
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
          RHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = b
                 index of
                  --- debug: UNRECOGNIZED EXPR ---
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = c
                 index of
                  --- debug: UNRECOGNIZED EXPR ---
  File_decl with these decls: 
    Part_decl: named 'Adder16_CLA', with stmts: 
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=public
        isMemory=0
        name: a
        name: b
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=public
        isMemory=0
        name: carryIn
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=public
        isMemory=0
        name: out
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=public
        isMemory=0
        name: carryOut
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=n/a
        isMemory=0
        name: g
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=n/a
        isMemory=0
        name: p
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=n/a
        isMemory=0
        name: G
        name: P
      stmt: FOR LOOP
        var: i
        Bgn:
          Expr: NUM, value of 0
        End=:
          Expr: NUM, value of 4
        Stmts:
          stmt: BLOCK, that has stmts...
            stmt: DECL:
              type:
                Expr: IDENT, name = SGP
              prefix=n/a
              isMemory=0
              name: super
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'g'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = g
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'p'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = p
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR, into array expr
                Expr: IDENT, name = G
               index of
                Expr: IDENT, name = i
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'G'
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR, into array expr
                Expr: IDENT, name = P
               index of
                Expr: IDENT, name = i
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'P'
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=n/a
        isMemory=0
        name: car1
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car1
         accessing field 'g'
        Expr: IDENT, name = G
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car1
         accessing field 'p'
        Expr: IDENT, name = P
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car1
         accessing field 'carryIn'
        Expr: IDENT, name = carryIn
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=n/a
        isMemory=0
        name: C
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 16
        prefix=n/a
        isMemory=0
        name: c
      stmt: FOR LOOP
        var: i
        Bgn:
          Expr: NUM, value of 0
        End=:
          Expr: NUM, value of 4
        Stmts:
          stmt: BLOCK, that has stmts...
            stmt: DECL:
              type:
                Expr: IDENT, name = CAR
              prefix=n/a
              isMemory=0
              name: car0
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'g'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = g
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'p'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = p
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'carryIn'
              Expr: ARR, into array expr
                Expr: IDENT, name = C
               index of
                Expr: IDENT, name = i
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = c
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'c'
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = out
        Expr: TWOOP of mode XOR with exprs
          LHand:
            Expr: TWOOP of mode XOR with exprs
              LHand:
                Expr: IDENT, name = a
              RHand:
                Expr: IDENT, name = b
          RHand:
            Expr: IDENT, name = c
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = carryOut
        Expr: TWOOP of mode BITWISE OR with exprs
          LHand:
            Expr: TWOOP of mode BITWISE OR with exprs
              LHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = a
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = b
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
              RHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = a
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = c
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
          RHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = b
                 index of
                  --- debug: UNRECOGNIZED EXPR ---
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = c
                 index of
                  --- debug: UNRECOGNIZED EXPR ---
  File_decl with these decls: 
    Part_decl: named 'Adder64_CLA', with stmts: 
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=public
        isMemory=0
        name: a
        name: b
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=public
        isMemory=0
        name: carryIn
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=public
        isMemory=0
        name: out
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=public
        isMemory=0
        name: carryOut
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: g
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: p
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: G
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: P
      stmt: FOR LOOP
        var: i
        Bgn:
          Expr: NUM, value of 0
        End=:
          Expr: NUM, value of 16
        Stmts:
          stmt: BLOCK, that has stmts...
            stmt: DECL:
              type:
                Expr: IDENT, name = SGP
              prefix=n/a
              isMemory=0
              name: super
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'g'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = g
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: NUM, value of 4
                  RHand:
                    Expr: IDENT, name = i
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: NUM, value of 4
                      RHand:
                        Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'p'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = p
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: NUM, value of 4
                  RHand:
                    Expr: IDENT, name = i
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: NUM, value of 4
                      RHand:
                        Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR, into array expr
                Expr: IDENT, name = G
               index of
                Expr: IDENT, name = i
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'G'
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR, into array expr
                Expr: IDENT, name = P
               index of
                Expr: IDENT, name = i
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'P'
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: GG
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: PP
      stmt: FOR LOOP
        var: i
        Bgn:
          Expr: NUM, value of 0
        End=:
          Expr: NUM, value of 4
        Stmts:
          stmt: BLOCK, that has stmts...
            stmt: DECL:
              type:
                Expr: IDENT, name = SGP
              prefix=n/a
              isMemory=0
              name: super
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'g'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = G
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: NUM, value of 4
                  RHand:
                    Expr: IDENT, name = i
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: NUM, value of 4
                      RHand:
                        Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'p'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = P
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: NUM, value of 4
                  RHand:
                    Expr: IDENT, name = i
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: NUM, value of 4
                      RHand:
                        Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR, into array expr
                Expr: IDENT, name = GG
               index of
                Expr: IDENT, name = i
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'G'
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR, into array expr
                Expr: IDENT, name = PP
               index of
                Expr: IDENT, name = i
              Expr: DOT, using expr
                Expr: IDENT, name = super
               accessing field 'P'
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: CC
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: car2
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car2
         accessing field 'g'
        Expr: IDENT, name = GG
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car2
         accessing field 'p'
        Expr: IDENT, name = PP
      stmt: CONNECTION, with left and right exprs:
        Expr: DOT, using expr
          Expr: IDENT, name = car2
         accessing field 'carryIn'
        Expr: IDENT, name = carryIn
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = CC
        Expr: DOT, using expr
          Expr: IDENT, name = car2
         accessing field 'carryBits'
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: C
      stmt: FOR LOOP
        var: i
        Bgn:
          Expr: NUM, value of 0
        End=:
          Expr: NUM, value of 4
        Stmts:
          stmt: BLOCK, that has stmts...
            stmt: DECL:
              type:
                Expr: IDENT, name = CAR
              prefix=n/a
              isMemory=0
              name: car1
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car1
               accessing field 'g'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = G
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car1
               accessing field 'p'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = P
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car1
               accessing field 'carryIn'
              Expr: ARR, into array expr
                Expr: IDENT, name = CC
               index of
                Expr: IDENT, name = i
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = C
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
              Expr: DOT, using expr
                Expr: IDENT, name = car1
               accessing field 'carryBits'
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 64
        prefix=n/a
        isMemory=0
        name: c
      stmt: FOR LOOP
        var: i
        Bgn:
          Expr: NUM, value of 0
        End=:
          Expr: NUM, value of 16
        Stmts:
          stmt: BLOCK, that has stmts...
            stmt: DECL:
              type:
                Expr: IDENT, name = CAR
              prefix=n/a
              isMemory=0
              name: car0
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'g'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = g
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'p'
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = g
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
            stmt: CONNECTION, with left and right exprs:
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'carryIn'
              Expr: ARR, into array expr
                Expr: IDENT, name = C
               index of
                Expr: IDENT, name = i
            stmt: CONNECTION, with left and right exprs:
              Expr: ARR_SLICE, into array expr
                Expr: IDENT, name = c
               lower bound
                Expr: TWOOP of mode TIMES with exprs
                  LHand:
                    Expr: IDENT, name = i
                  RHand:
                    Expr: NUM, value of 4
               upper bound
                Expr: TWOOP of mode PLUS with exprs
                  LHand:
                    Expr: TWOOP of mode TIMES with exprs
                      LHand:
                        Expr: IDENT, name = i
                      RHand:
                        Expr: NUM, value of 4
                  RHand:
                    Expr: NUM, value of 4
              Expr: DOT, using expr
                Expr: IDENT, name = car0
               accessing field 'carryBits'
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = out
        Expr: TWOOP of mode XOR with exprs
          LHand:
            Expr: TWOOP of mode XOR with exprs
              LHand:
                Expr: IDENT, name = a
              RHand:
                Expr: IDENT, name = b
          RHand:
            Expr: IDENT, name = c
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = carryOut
        Expr: TWOOP of mode BITWISE OR with exprs
          LHand:
            Expr: TWOOP of mode BITWISE OR with exprs
              LHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = a
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = b
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
              RHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = a
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = c
                     index of
                      --- debug: UNRECOGNIZED EXPR ---
          RHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = b
                 index of
                  --- debug: UNRECOGNIZED EXPR ---
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = c
                 index of
                  --- debug: UNRECOGNIZED EXPR ---
  File_decl with these decls: 
    Part_decl: named 'SGP', with stmts: 
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: g
        name: p
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: G
        name: P
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = P
        Expr: TWOOP of mode BITWISE AND with exprs
          LHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = p
                     index of
                      Expr: NUM, value of 0
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = p
                     index of
                      Expr: NUM, value of 1
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = p
                 index of
                  Expr: NUM, value of 2
          RHand:
            Expr: ARR, into array expr
              Expr: IDENT, name = p
             index of
              Expr: NUM, value of 3
      stmt: CONNECTION, with left and right exprs:
        Expr: IDENT, name = G
        Expr: TWOOP of mode BITWISE AND with exprs
          LHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: TWOOP of mode BITWISE OR with exprs
                      LHand:
                        Expr: TWOOP of mode BITWISE AND with exprs
                          LHand:
                            Expr: TWOOP of mode BITWISE AND with exprs
                              LHand:
                                Expr: TWOOP of mode BITWISE OR with exprs
                                  LHand:
                                    Expr: TWOOP of mode BITWISE AND with exprs
                                      LHand:
                                        Expr: TWOOP of mode BITWISE OR with exprs
                                          LHand:
                                            Expr: ARR, into array expr
                                              Expr: IDENT, name = G
                                             index of
                                              Expr: NUM, value of 3
                                          RHand:
                                            Expr: ARR, into array expr
                                              Expr: IDENT, name = P
                                             index of
                                              Expr: NUM, value of 3
                                      RHand:
                                        Expr: ARR, into array expr
                                          Expr: IDENT, name = G
                                         index of
                                          Expr: NUM, value of 2
                                  RHand:
                                    Expr: ARR, into array expr
                                      Expr: IDENT, name = P
                                     index of
                                      Expr: NUM, value of 3
                              RHand:
                                Expr: ARR, into array expr
                                  Expr: IDENT, name = P
                                 index of
                                  Expr: NUM, value of 2
                          RHand:
                            Expr: ARR, into array expr
                              Expr: IDENT, name = G
                             index of
                              Expr: NUM, value of 1
                      RHand:
                        Expr: ARR, into array expr
                          Expr: IDENT, name = P
                         index of
                          Expr: NUM, value of 3
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = P
                     index of
                      Expr: NUM, value of 2
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = P
                 index of
                  Expr: NUM, value of 1
          RHand:
            Expr: ARR, into array expr
              Expr: IDENT, name = G
             index of
              Expr: NUM, value of 0
  File_decl with these decls: 
    Part_decl: named 'CAR', with stmts: 
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: g
        name: p
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: carryIn
      stmt: DECL:
        type:
          Expr: ARR, into array expr
            "bit"
           index of
            Expr: NUM, value of 4
        prefix=public
        isMemory=0
        name: carryBits
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: IDENT, name = carryBits
         index of
          Expr: NUM, value of 0
        Expr: IDENT, name = carryIn
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: IDENT, name = carryBits
         index of
          Expr: NUM, value of 1
        Expr: TWOOP of mode BITWISE AND with exprs
          LHand:
            Expr: TWOOP of mode BITWISE OR with exprs
              LHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = g
                 index of
                  Expr: NUM, value of 0
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = p
                 index of
                  Expr: NUM, value of 0
          RHand:
            Expr: IDENT, name = carryIn
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: IDENT, name = carryBits
         index of
          Expr: NUM, value of 2
        Expr: TWOOP of mode BITWISE AND with exprs
          LHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: TWOOP of mode BITWISE OR with exprs
                  LHand:
                    Expr: TWOOP of mode BITWISE AND with exprs
                      LHand:
                        Expr: TWOOP of mode BITWISE OR with exprs
                          LHand:
                            Expr: ARR, into array expr
                              Expr: IDENT, name = g
                             index of
                              Expr: NUM, value of 1
                          RHand:
                            Expr: ARR, into array expr
                              Expr: IDENT, name = p
                             index of
                              Expr: NUM, value of 1
                      RHand:
                        Expr: ARR, into array expr
                          Expr: IDENT, name = g
                         index of
                          Expr: NUM, value of 0
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = p
                     index of
                      Expr: NUM, value of 1
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = p
                 index of
                  Expr: NUM, value of 0
          RHand:
            Expr: IDENT, name = carryIn
      stmt: CONNECTION, with left and right exprs:
        Expr: ARR, into array expr
          Expr: IDENT, name = carryBits
         index of
          Expr: NUM, value of 3
        Expr: TWOOP of mode BITWISE AND with exprs
          LHand:
            Expr: TWOOP of mode BITWISE AND with exprs
              LHand:
                Expr: TWOOP of mode BITWISE AND with exprs
                  LHand:
                    Expr: TWOOP of mode BITWISE OR with exprs
                      LHand:
                        Expr: TWOOP of mode BITWISE AND with exprs
                          LHand:
                            Expr: TWOOP of mode BITWISE AND with exprs
                              LHand:
                                Expr: TWOOP of mode BITWISE OR with exprs
                                  LHand:
                                    Expr: TWOOP of mode BITWISE AND with exprs
                                      LHand:
                                        Expr: TWOOP of mode BITWISE OR with exprs
                                          LHand:
                                            Expr: ARR, into array expr
                                              Expr: IDENT, name = g
                                             index of
                                              Expr: NUM, value of 2
                                          RHand:
                                            Expr: ARR, into array expr
                                              Expr: IDENT, name = p
                                             index of
                                              Expr: NUM, value of 2
                                      RHand:
                                        Expr: ARR, into array expr
                                          Expr: IDENT, name = g
                                         index of
                                          Expr: NUM, value of 1
                                  RHand:
                                    Expr: ARR, into array expr
                                      Expr: IDENT, name = p
                                     index of
                                      Expr: NUM, value of 2
                              RHand:
                                Expr: ARR, into array expr
                                  Expr: IDENT, name = p
                                 index of
                                  Expr: NUM, value of 1
                          RHand:
                            Expr: ARR, into array expr
                              Expr: IDENT, name = g
                             index of
                              Expr: NUM, value of 0
                      RHand:
                        Expr: ARR, into array expr
                          Expr: IDENT, name = p
                         index of
                          Expr: NUM, value of 2
                  RHand:
                    Expr: ARR, into array expr
                      Expr: IDENT, name = p
                     index of
                      Expr: NUM, value of 1
              RHand:
                Expr: ARR, into array expr
                  Expr: IDENT, name = p
                 index of
                  Expr: NUM, value of 0
          RHand:
            Expr: IDENT, name = carryIn

rc=0
