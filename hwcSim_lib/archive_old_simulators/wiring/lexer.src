%{
#include <string.h>

#include "parsercommon.h"      // our own code, written by hand

#include "parser.tab.h"        // auto-generated by Bison

int  colNum = 1;

int yydebug = 1;

/* This macro runs just before we run the match-code for every rule below;
 * basically, it's a standard prefix.  By the time this runs, we know *which*
 * rule has been matched, and its length.
 *
 * We use this opportunity to update the yylloc variable (which is used by
 * Bison); we also update the colNum variable to keep track of the current
 * column.  (We handle newlines, where colNum needs to be reset, with a line
 * down in the rule - all of the other rules only need this standard code.)
 *
 * Since this happens for *all* rules (including whitespace matches), the
 * column number is always correct.  And BTW, the yylineno variable is
 * automatically handled by flex, since we set the yylineno option below.
 */
#define YY_USER_ACTION                                   \
    do {                                                 \
      yylloc.first_line   = yylloc.last_line = yylineno; \
      yylloc.first_column = colNum;                      \
      yylloc. last_column = colNum + yyleng-1;           \
      colNum += yyleng;                                  \
    } while (0);

%}


  /* disable some lex features that we don't need (for now) */
%option noyywrap
%option nounput
%option noinput

  /* this turns on automatic filling of the yylineno variable.  Unfortunately,
   * it does not track columns.
   */
%option yylineno



%%


  /* NOTE: Start comments with a little indentation, so that flex doesn't see
   *       slash-star as a matching rule.
   */

  /* TRIVIAL MATCHES
   *
   * If we hit EOF, terminate the parse; if we hit a newline, lex will increment
   * yylineno on our behalf, and we will update colNum, but we do nothing else;
   * if we hit any *other* whitespace, then simply swallow it, one character at
   * a time.
   */
<<EOF>>			return 0;
\n			colNum=1;
[ \t\r]			  /* NOP */



  /* HASH SYMBOL LINE COMMENTS
   *
   * When you see the start of the comment, consume the entire line *EXCEPT*
   * for the newline at the end.  (This allows the newline rule above to kick
   * in, immediately after this.)
   */
[#][^\n]*			/* no action */



  /* NUMERIC CONSTANTS
   *
   * Matches decimal or hexdecimal constants.  Underscores are allowed anywhere,
   * and ignored.
   *
   * Negative constants are not allowed.
   *
   * UPDATE: Support the keyword "ZERO" as a special NUM, representing a
   *         compile-time constant of flexible length.  We'll use
   *         WIRING_CONST_ZERO as the value; core.h defines that (and other
   *         negative "numbers", which represent other special cases, such as
   *         WIRING_BIT_INVALID).
   */
0|[1-9][0-9]*		yylval.num = atoi(yytext); return NUM;
"ZERO"                  yylval.num = WIRING_CONST_ZERO; return NUM;


  /* STRINGS */
\"(\\[^\n]|[^"\n])*\"	yylval.str = strdup(yytext); return STR;



  /* KEYWORDS
   *
   * This matches all keywords.  (This language doesn't have identifiers.)
   *
   * To figure out how to interpret each keyword that we see, we must compare
   * it to the table of strings generated by bison; if we find a match, then
   * we will return the assigned token ID for this keyword.
   *
   * If not, the parse terminates.
   *
   * UPDATE: Moved this *below* NUM, so that we could handle the "ZERO" keyword.
   */
_*[a-zA-Z][_a-zA-Z0-9]*		return tokenLookup(yytext);



  /* OPERATORS
   *
   * This lists all of the operators in the language; in this language, they all
   * are a single character only, so we can just return the ASCII value as the
   * token type.
   */
[:.=()]			return yytext[0];

  /* LEXER ERROR, the default case */
.				{ printf("Unrecognized character %d='%c' at line %d col %d.\n",yytext[0],yytext[0], yylloc.first_line, yylloc.first_column); return 256; }

